# Blocks


## Introduction to CAR and SAR models


In this section we model aerial data, which is data that occurs on a lattice or an irregular grid with a countable set of locations or nodes. The two most common models for aerial data are conditional autoregressive (CAR) and simultaneous autoregressive (SAR) models, both know for having sparse precision matrices. For a review of these models see @SAR, @riebler2016intuitive and the relationship between then was studied in @ver2018relationship. Here we consider a SAR model built using the following relationship:

$$
\mathbf{x} = \mathbf{B}\mathbf{x} + \sigma\mathbf{Z},
$$
where each element of the random vector $\mathbf{x}$ corresponds to a node and $\mathbf{Z}$ is a vector of i.i.d standard Gaussian noise. The matrix $\mathbf{B}$ causes simultaneous autoregressions of each random variable on its neighbors. Hence, SAR models are typically added as spatially structured random effects in hierarchical models in many fields such as disease mapping, ecology and econometrics. The diagonal elements of $\mathbf{B}$ are 0 so that each node does not depend on itself. For simplicity we assume $\mathbf{B}=\rho\mathbf{W}$, where $\mathbf{W}$ is a row standardized adjacency matrix and $-1<\rho<1$ so that the resulting precision matrix is valid. We end up with a system $\mathbf{D}_{SAR}\mathbf{x} = \sigma\mathbf{Z}$, where $\mathbf{D}_{SAR}=\mathbf{I}-\rho\mathbf{W}$. The equivalent model driven by NIG noise is then $\mathbf{D}_{SAR}\mathbf{x} = \sigma\mathbf{\Lambda}$, where $\mathbf{\Lambda}$ is i.i.d. standardized NIG noise with parameters $\eta^\star$ and $\mu^\star$.

Jeffrey prior for SAR
https://www.jstor.org/stable/41234438?seq=9#metadata_info_tab_contents

<!--
The word "conditional" on CAR is due to the fact that the distribution of each node is defined conditionally on the values of the neighboring nodes:

$$
x_i|\mathbf{x_{-i}} \sim \mathcal{N}(\frac{1}{n_i}\sum_{j:j\sim i}x_j,\frac{\sigma^2}{n_i}),
$$
where $\mathbf{x_{-i}}$ is a vector containing all $z_j$ except $j \neq i$, $i \sim j$ denotes the set of all unordered pairs of neighbors and $n_i$ is the number of neighbors of node $i$. Two regions are considered to be neighbors if they share a common border. The CAR model is typically added as a component to hierarchical models, in many fields such as disease mapping, ecology and econometrics, in order to model spatial correlation in the data, since the conditional mean of $x_i$ in eq. is the average of the values of the neighbors. The previous conditional structure leads to a GMRF with a precision matrix with a rank deficiency of 1, given by:

$$
A_{i j}=\left\{\begin{array}{ll}
-1, & i \text { is neighboring } j \\
n_i, & i=j \\
0, & \text { else. }
\end{array}\right.
$$

-->

```{r}
library(spdep)
library(sp)
library(rgdal)
library(leaflet)
library(cmdstanr)
library(posterior)
library(bayesplot)
source("../files/utils.R")

options(mc.cores = parallel::detectCores())
```

## Columbus dataset

```{r}
data(columbus)
data <- columbus[,c("CRIME","HOVAL","INC")]
N    <- nrow(data)
map  <- readOGR(system.file("shapes/columbus.shp", package="spData")[1])
proj4string(map) <- CRS("+proj=longlat +datum=WGS84")
map  <- spTransform(map,CRS("+proj=longlat +datum=WGS84 +no_defs"))
```

```{r}
rownames(data) <- 1:N-1
map <- SpatialPolygonsDataFrame(map, data)

pal_crime <- colorNumeric(palette = "YlOrRd", domain = map$CRIME)
pal_hoval <- colorNumeric(palette = "YlOrRd", domain = map$HOVAL)
pal_inc   <- colorNumeric(palette = "YlOrRd", domain = map$INC)
leaflet(map) %>%
  addPolygons( color = "grey", weight = 1, fillColor = ~ pal_crime(CRIME), fillOpacity = 0.6, group = "Crime")   %>%
  addPolygons( color = "grey", weight = 1, fillColor = ~ pal_hoval(HOVAL), fillOpacity = 0.6, group = "House Value")   %>%
  addPolygons( color = "grey", weight = 1, fillColor = ~ pal_inc(INC),     fillOpacity = 0.6, group = "Income")  %>%
  addLegend_decreasing(pal = pal_crime, values = ~CRIME,title = "Crime (in thousands)",
                       position = "bottomright", decreasing = TRUE, group = "Crime")  %>%
  addLegend_decreasing(pal = pal_hoval, values = ~HOVAL,title = "Average Household Value",
                       position = "bottomright", decreasing = TRUE, group = "House Value")  %>%
  addLegend_decreasing(pal = pal_hoval, values = ~INC,  title = "Average Household Income",
                       position = "bottomright", decreasing = TRUE, group = "Income") %>%
  addLayersControl(overlayGroups = c("Crime", "House Value","Income"),
                   options = layersControlOptions(collapsed = FALSE))  %>%
  hideGroup("House Value")  %>%
  hideGroup("Income") 
```

```{r}
nb_q <- poly2nb(map)
nb_B <- nb2listw(nb_q, style="B", zero.policy=TRUE)
B    <- as(nb_B, "sparseMatrix")
A    <- diag(N,rowSums(B)) - B
```


```{r}
B <- cbind(rep(1,N),data[,c(2,3)]) #Design matrix

dat1 <- list(N            = N,
             N_covariates = 3,
             y            = data$CRIME,
             B            = B,
             A            = as.matrix(A),
             inter_points = inter_points,
             kappa_log    = kappa_log,
             det_log      = det_log,
             thetaetas    = 5,
             thetamus     = 4)
```


```{r}
model_stan_Gauss <- cmdstan_model('../files/stan/GaussSAR.stan')
fit_Gauss <- model_stan_Gauss$sample(data = dat1, 
                                     chains = 4, 
                                     iter_warmup = 500, 
                                     iter_sampling = 2000,
                                     max_treedepth = 20,
                                     adapt_delta = 0.95)

fit_Gauss$save_object("fit_columbus_Gauss.rds")
``` 

```{r}
model_stan_NIG <- cmdstan_model('../files/stan/NIGSAR.stan')
fit_NIG <- model_stan_NIG$sample(data = dat1, 
                                 chains = 4, 
                                 iter_warmup = 500, 
                                 iter_sampling = 2000,
                                 max_treedepth = 20,
                                 adapt_delta = 0.99)

fit_NIG$save_object("fit_columbus_NIG.rds")
``` 

```{r}
fit_Gauss <- readRDS("fit_columbus_Gauss.rds")
fit_NIG   <- readRDS("fit_columbus_NIG.rds")

mcmc_pairs(fit_Gauss$draws(c("sigmae", "sigma", "kappa")),
           diag_fun="dens", off_diag_fun="hex")

mcmc_trace(fit_Gauss$draws(c("sigmae", "sigma", "kappa")), 
           facet_args = list(ncol = 2, strip.position = "left"))


mcmc_pairs(fit_NIG$draws(c("sigmae", "sigma", "kappa", "etas", "mus")),
           diag_fun="dens", off_diag_fun="hex")

mcmc_trace(fit_NIG$draws(c("sigmae", "sigma", "kappa", "etas", "mus")), 
           facet_args = list(ncol = 2, strip.position = "left"))

bayesplot_grid(
  mcmc_hist(fit_Gauss$draws("beta[1]")),
  mcmc_hist(fit_NIG$draws("beta[1]")),
  titles = c("Intercept - Gaussian model", "Intercept - NIG model"),
  xlim = c(0, 200)
)

bayesplot_grid(
  mcmc_hist(fit_Gauss$draws("beta[2]")),
  mcmc_hist(fit_NIG$draws("beta[2]")),
  titles = c("Reg. coeff. house value - Gaussian model", "Reg. coeff. house value - NIG model"),
  xlim = c(-0.7, 0)
)

bayesplot_grid(
  mcmc_hist(fit_Gauss$draws("beta[3]")),
  mcmc_hist(fit_NIG$draws("beta[3]")),
  titles = c("Reg. coeff. income - Gaussian model", "Reg. coeff. income - NIG model"),
  xlim = c(-2, 0)
)
``` 


```{r}
fit_Gauss$loo()
fit_NIG$loo()

library(loo)
waic(fit_Gauss$draws("log_lik"))
waic(fit_NIG$draws("log_lik"))
```

```{r}
X     <- as.matrix(as_draws_df(fit_NIG$draws("X")))[,1:N]
etas  <- as.matrix(as_draws_df(fit_NIG$draws("etas")))[,1]
mus   <- as.matrix(as_draws_df(fit_NIG$draws("mus")))[,1]
kappa <- as.matrix(as_draws_df(fit_NIG$draws("kappa")))[,1]
h     <- rep(1,N)

V_post <- Vposterior(X, kappa, A, etas, mus, h)
```

```{r}
sigma      <- as.matrix(as_draws_df(fit_NIG$draws("sigma")))[,1]
sigmaX     <- sigma*as.matrix(as_draws_df(fit_NIG$draws("X")))[,1:N]
V          <- colMeans(V_post)

data$xmean <- colMeans(sigmaX)
data$xsd   <- apply(sigmaX,2,sd)
data$V     <- V
#data$xmean    <- colMeans(as.matrix(as_draws_df(fit_Gauss$draws("my")))[,1:N])
#data$xsd  <- apply(as.matrix(as_draws_df(fit_Gauss$draws("my")))[,1:N],2,sd)

rownames(data) <- 1:N-1
map <- SpatialPolygonsDataFrame(map, data)
pal_xmean <- colorNumeric(palette = c("blue","white","red"), domain = map$xmean)
pal_xsd   <- colorNumeric(palette = "YlOrRd", domain = map$xsd)
pal_V     <- colorNumeric(palette = "YlOrRd", domain = map$V)
leaflet(map) %>%
  addPolygons( color = "grey", weight = 1, fillColor = ~ pal_xmean(xmean), fillOpacity = 0.6, group = "X mean")   %>%
  addPolygons( color = "grey", weight = 1, fillColor = ~ pal_xsd(xsd)    , fillOpacity = 0.6, group = "X sd"  )   %>%
  addPolygons( color = "grey", weight = 1, fillColor = ~ pal_V(V)        , fillOpacity = 0.6, group = "V mean"  )   %>%
  addLegend_decreasing(pal = pal_xmean, values = ~xmean,title = "Mean of Spatial effects",
                       position = "bottomright", decreasing = TRUE, group = "X mean")  %>%
  addLegend_decreasing(pal = pal_xsd, values = ~xsd, title = "SD of Spatial effects",
                       position = "bottomright", decreasing = TRUE, group = "X sd")  %>%
  addLegend_decreasing(pal = pal_V, values = ~V, title = "mean of V",
                       position = "bottomright", decreasing = TRUE, group = "V mean")  %>%
  addLayersControl(overlayGroups = c("X mean", "X sd","V mean"),
                   options = layersControlOptions(collapsed = FALSE))  %>%
  hideGroup(c("X sd","V mean")) 
```


## Slovenia dataset

```{r}
library(RASCO)
library(spdep)
data("slovenia")
```

```{r}
data <- as.data.frame(slovenia)[,c("O","E","SEc")] 
data$SIR <- data$O/data$E
N    <- nrow(data)
```

```{r}
nb_q <- poly2nb(as(st_geometry(slovenia), "Spatial"))
nb_B <- nb2listw(nb_q, style="B", zero.policy=TRUE)
B    <- as(nb_B, "sparseMatrix")
A    <- Diagonal(N,rowSums(B)) - B
```


```{r}
geom <- as(st_geometry(slovenia), "Spatial")
proj4string(geom) <- CRS("+proj=utm")
geom <- spTransform(map, CRS("+proj=longlat +datum=WGS84 +no_defs"))

rownames(data) <- paste("ID",1:N,sep="")
data$ID <- 1:N
mapdata <- SpatialPolygonsDataFrame(geom, data)

labels <- sprintf("<strong> %s </strong> <br/>
  Observed: %s <br/> Expected: %s <br/>
  SEC: %s <br/> SIR: %s",
  mapdata$ID, mapdata$O, round(mapdata$E, 2), round(mapdata$SEc, 2), round(mapdata$SIR, 2) ) %>% lapply(htmltools::HTML)

pal <- colorNumeric(palette = "YlOrRd", domain = mapdata$SIR)
leaflet(mapdata) %>%
  addPolygons(color = "grey", weight = 1, fillColor = ~ pal(SIR),
    fillOpacity = 0.5,
    highlightOptions = highlightOptions(weight = 4),
    label = labels,
    labelOptions = labelOptions(
      style =
        list(
          "font-weight" = "normal",
          padding = "3px 8px"
        ),
      textsize = "15px", direction = "auto"
    )
  ) %>%
  addLegend_decreasing(
    pal = pal, values = ~SIR, opacity = 0.5, title = "",
    position = "bottomright", decreasing = TRUE)
```

```{r}
library(RASCO)
library(spdep)
data("slovenia")
```

```{r}
data <- as.data.frame(slovenia)[,c("O","E","SEc")] 
data$SIR <- data$O/data$E
N    <- nrow(data)
```

```{r}
nb_q <- poly2nb(as(st_geometry(slovenia), "Spatial"))
nb_B <- nb2listw(nb_q, style="B", zero.policy=TRUE)
B    <- as(nb_B, "sparseMatrix")
A    <- Diagonal(N,rowSums(B)) - B
```


```{r}
geom <- as(st_geometry(slovenia), "Spatial")
proj4string(geom) <- CRS("+proj=utm")
geom <- spTransform(map, CRS("+proj=longlat +datum=WGS84 +no_defs"))

rownames(data) <- paste("ID",1:N,sep="")
data$ID <- 1:N
mapdata <- SpatialPolygonsDataFrame(geom, data)

labels <- sprintf("<strong> %s </strong> <br/>
  Observed: %s <br/> Expected: %s <br/>
  SEC: %s <br/> SIR: %s",
  mapdata$ID, mapdata$O, round(mapdata$E, 2), round(mapdata$SEc, 2), round(mapdata$SIR, 2) ) %>% lapply(htmltools::HTML)

pal <- colorNumeric(palette = "YlOrRd", domain = mapdata$SIR)
leaflet(mapdata) %>%
  addPolygons(color = "grey", weight = 1, fillColor = ~ pal(SIR),
    fillOpacity = 0.5,
    highlightOptions = highlightOptions(weight = 4),
    label = labels,
    labelOptions = labelOptions(
      style =
        list(
          "font-weight" = "normal",
          padding = "3px 8px"
        ),
      textsize = "15px", direction = "auto"
    )
  ) %>%
  addLegend_decreasing(
    pal = pal, values = ~SIR, opacity = 0.5, title = "",
    position = "bottomright", decreasing = TRUE)
```

```{r}
a <- -10
b <- 10
inter_points <- 1000
kappa_log <- seq(a,b,,inter_points)
det_log <-c()
for(kappa in exp(kappa_log)){
  D       <- Diagonal(N, kappa^2) + A
  det_log <- c(det_log, determinant(D,logarithm = TRUE)$modulus[1])
}

plot(kappa_log,det_log)
```

```{r}
B <- cbind(rep(1,N),data$SEc) #Design matrix

dat1 <- list(N            = N,
             N_covariates = 2,
             O            = data$O,
             logE         = log(data$E),
             B            = B,
             A            = as.matrix(A),
             inter_points = inter_points,
             kappa_log    = kappa_log,
             det_log      = det_log,
             thetaetas    = 5,
             thetamus     = 4)
```


```{r}
model_stan_Gauss <- cmdstan_model('../files/stan/GaussPoissonSAR.stan')
fit_Gauss <- model_stan_Gauss$sample(data = dat1, 
                                     chains = 4, 
                                     iter_warmup = 200, 
                                     iter_sampling = 1000)

fit_Gauss$save_object("fit_slovenia_Gauss.rds")
``` 

```{r}
model_stan_NIG <- cmdstan_model('../files/stan/NIGPoissonSAR.stan')
fit_NIG <- model_stan_NIG$sample(data = dat1, 
                                 chains = 4, 
                                 iter_warmup = 200, 
                                 iter_sampling = 1000)

fit_NIG$save_object("fit_slovenia_NIG.rds")
``` 


```{r}
fit_Gauss <- readRDS("fit_slovenia_Gauss.rds")
fit_NIG   <- readRDS("fit_slovenia_NIG.rds")

mcmc_pairs(fit_Gauss$draws(c("sigma_theta", "sigma_X", "kappa")),
           diag_fun="dens", off_diag_fun="hex")

mcmc_trace(fit_Gauss$draws(c("sigma_theta", "sigma_X", "kappa")), 
           facet_args = list(ncol = 2, strip.position = "left"))

mcmc_pairs(fit_NIG$draws(c("sigma_theta", "sigma_X", "kappa", "etas", "mus")),
           diag_fun="dens", off_diag_fun="hex")

mcmc_trace(fit_NIG$draws(c("sigma_theta", "sigma_X", "kappa", "etas", "mus")), 
           facet_args = list(ncol = 2, strip.position = "left"))

bayesplot_grid(
  mcmc_hist(fit_Gauss$draws("beta[1]")),
  mcmc_hist(fit_NIG$draws("beta[1]")),
  titles = c("Intercept - Gaussian model", "Intercept - NIG model"),
  xlim = c(-0.1, 0.3)
)

bayesplot_grid(
  mcmc_hist(fit_Gauss$draws("beta[2]")),
  mcmc_hist(fit_NIG$draws("beta[2]")),
  titles = c("Reg. coeff. house value - Gaussian model", "Reg. coeff. house value - NIG model"),
  xlim = c(-0.2, 0)
)

```

```{r}
fit_Gauss$loo()
fit_NIG$loo()

library(loo)
waic(fit_Gauss$draws("log_lik"))
waic(fit_NIG$draws("log_lik"))
```

```{r}
X     <- as.matrix(as_draws_df(fit_NIG$draws("X")))[,1:N]
sigma <- as.matrix(as_draws_df(fit_NIG$draws("sigma_X")))[,1]
etas  <- as.matrix(as_draws_df(fit_NIG$draws("etas")))[,1]
mus   <- as.matrix(as_draws_df(fit_NIG$draws("mus")))[,1]
kappa <- as.matrix(as_draws_df(fit_NIG$draws("kappa")))[,1]
h     <- rep(1,N)

V_post <- Vposterior(X, kappa, A, etas, mus, h)
```


```{r}
rownames(data) <- paste("ID",1:N,sep="")
data$ID        <- 1:N
data$V         <- colMeans(V_post)
data$xmean     <- colMeans(sigma*X)
data$xsd       <- apply(sigma*X,2,sd)

mapdata <- SpatialPolygonsDataFrame(geom, data)


pal_xmean   <- colorNumeric(palette = c("blue","white","red"), domain = mapdata$xmean)
pal_xsd     <- colorNumeric(palette = "YlOrRd", domain = mapdata$xsd)
pal_V       <- colorNumeric(palette = "YlOrRd", domain = mapdata$V)
leaflet(mapdata) %>%
  addPolygons(color = "grey", weight = 1, fillColor = ~ pal_xmean(xmean)   , fillOpacity = 0.5, group = "X mean") %>%
  addPolygons(color = "grey", weight = 1, fillColor = ~ pal_xsd(xsd)   , fillOpacity = 0.5, group = "X sd") %>%
  addPolygons(color = "grey", weight = 1, fillColor = ~ pal_V(V)       , fillOpacity = 0.5, group = "V mean") %>%
  addLegend_decreasing(pal = pal_xmean, values = ~xmean,title = "Mean of Spatial effects",
                       position = "bottomright", decreasing = TRUE, group = "X mean")  %>%
  addLegend_decreasing(pal = pal_xsd, values = ~xsd, title = "SD of Spatial effects",
                       position = "bottomright", decreasing = TRUE, group = "X sd")  %>%
  addLegend_decreasing(pal = pal_V, values = ~V, title = "mean of V",
                       position = "bottomright", decreasing = TRUE, group = "V mean")  %>%
  addLayersControl(overlayGroups = c("X mean", "X sd","V mean"),
                   options = layersControlOptions(collapsed = FALSE))  %>%
  addLayersControl(overlayGroups = c("X mean", "X sd","V mean"),
                   options = layersControlOptions(collapsed = FALSE))  %>%
  hideGroup(c("X sd","V mean")) 
  
```
