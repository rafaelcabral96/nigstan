mydf <- data.frame(Observation = c("A", "B"),   #Line coordinates
InitialLat = centr[node1,2],
InitialLong = centr[node1,1],
NewLat = centr[node2,2],
NewLong = centr[node2,1],
stringsAsFactors = FALSE)
labels <- sprintf("<strong> %s </strong> <br/>
Observed: %s <br/> Expected: %s <br/>
AFF: %s <br/> SIR: %s <br/> RR: %s (%s, %s)  <br/> P(RR>2): %s",
map$county, y, round(E, 2),
x, round(map$SIR, 2), round(map$RR, 2),
round(map$LL, 2), round(map$UL, 2),  round(map$exc, 2)) %>% lapply(htmltools::HTML)
pal    <- colorNumeric(palette = "YlOrRd", domain = map$RR)
palexc <- colorNumeric(palette = "YlOrRd", domain = map$exc)
palV    <- colorNumeric(palette = "YlOrRd", domain = V)
ll <- leaflet(map) %>%
addTiles(group = "OpenStreetMap") %>%
addProviderTiles(providers$Esri.WorldImagery, group = "Sattelite") %>%
addPolygons(
color = "grey", weight = 1, fillColor = ~ pal(RR),
fillOpacity = 0.5,
highlightOptions = highlightOptions(weight = 4),
label = labels,
labelOptions = labelOptions(
style =list("font-weight" = "normal",padding = "3px 8px"),
textsize = "15px", direction = "auto"), group = "RR") %>%
addLegend_decreasing(
pal = pal, values = ~RR, opacity = 0.5, title = "Relative risk mean",
position = "bottomright", decreasing = TRUE, group = "RR") %>%
addPolygons(
color = "grey", weight = 1, fillColor = ~ palexc(exc),
fillOpacity = 0.5,
highlightOptions = highlightOptions(weight = 4),
label = labels,
labelOptions = labelOptions(
style =list("font-weight" = "normal",padding = "3px 8px"),
textsize = "15px", direction = "auto"), group = "Exceedance") %>%
addLegend_decreasing(
pal = palexc, values = ~exc, opacity = 0.5, decreasing = TRUE,
title = "P(RR>2)", position = "bottomright", group = "Exceedance") %>%
addPolygons(data = map, color = "grey", opacity =0.9, weight = 1,
highlightOptions = highlightOptions(weight = 4),
label = labels, group = "V mean",
labelOptions = labelOptions(
style =list("font-weight" = "normal",padding = "3px 8px"),
textsize = "15px", direction = "auto")) %>%
addLegend_decreasing(
pal = palV, values = V, opacity = 0.5, decreasing = TRUE,
title = "V mean", position = "bottomright", group = "V mean")  %>%
addLayersControl(overlayGroups = c("RR", "Exceedance","V mean"),
baseGroups = c("OpenStreetMap", "Sattelite"),
options = layersControlOptions(collapsed = FALSE))  %>%
hideGroup(c("Exceedance","V mean"))  %>%
addFullscreenControl()
for(i in 1:nrow(mydf)){
ll <- addPolylines(ll, lat = as.numeric(mydf[i, c(2, 4)]),
lng = as.numeric(mydf[i, c(3, 5)]),
color = palV(V[i]), opacity = 1,
weight = 3, group = "V mean")
}
ll
model_stan_NIG <- cmdstan_model('../files/stan/ARNIG.stan')
fit_NIG <- model_stan_NIG$sample(data = dat1,
chains = 4,
iter_warmup   = 200,
iter_sampling = 1000,
max_treedepth = 25)
fit_NIG$save_object("../files/fits/ARNIG.rds") #no warning
model_stan_NIG <- cmdstan_model('../files/stan/ARNIG.stan')
model_stan_NIG <- cmdstan_model('../files/stan/ARNIG.stan')
model_stan_NIG <- cmdstan_model('../files/stan/ARNIG.stan')
fit_NIG <- model_stan_NIG$sample(data = dat1,
chains = 4,
iter_warmup   = 200,
iter_sampling = 1000,
max_treedepth = 25)
library(readr)                # Read csv files
library(cmdstanr)             # CmdStan R interface
library(posterior)            # Process the output of cmdstanr sampling
library(bayesplot)            # Pair and trace plots
library(ggplot2)              # More plots
library(SuppDists)            # Evaluate density of a InvGauss distribution
source("../files/utils.R")    # Several utility functions
options(mc.cores = parallel::detectCores())
goog <- as.data.frame(read_csv("../files/data/GOOG.csv", col_names = TRUE))
data <- goog$Close #closing prices
N    <- length(data)
mcmc_trace(as.data.frame(iter= 1:N, x = data))
dat1 <- list(N = N,
x = data,
theta_etas   = 15,
theta_zetas  = 6.5)
model_stan_Gauss <- cmdstan_model('../files/stan/ARGauss.stan')
fit_Gauss <- model_stan_Gauss$sample(data = dat1,
chains = 4,
iter_warmup   = 200,
iter_sampling = 1000)
fit_Gauss$save_object("../files/fits/ARGauss.rds")
model_stan_Gauss <- cmdstan_model('../files/stan/ARGauss.stan')
fit_Gauss <- model_stan_Gauss$sample(data = dat1,
chains = 4,
iter_warmup   = 500,
iter_sampling = 3000)
fit_Gauss$save_object("../files/fits/ARGauss.rds")
model_stan_NIG <- cmdstan_model('../files/stan/ARNIG.stan')
fit_NIG <- model_stan_NIG$sample(data = dat1,
chains = 4,
iter_warmup   = 200,
iter_sampling = 3000,
max_treedepth = 25)
model_stan_NIG <- cmdstan_model('../files/stan/ARNIG.stan')
fit_NIG <- model_stan_NIG$sample(data = dat1,
chains = 4,
iter_warmup   = 200,
iter_sampling = 1000,
max_treedepth = 25)
fit_Gauss <- readRDS("../files/fits/fit_press_Gauss500.rds")
knitr::kable(head(fit_Gauss$summary(),7), "simple", row.names = NA, digits=2)
fit_NIG <- readRDS("../files/fits/fit_press_500.rds")
knitr::kable(head(fit_NIG$summary(),7), "simple", row.names = NA, digits=2)
#Square grid containing 100^2 nodes
n.grid <- 100
coop <- as.data.frame(expand.grid(seq(min(weatherdata$lon),max(weatherdata$lon),,n.grid),
seq(min(weatherdata$lat),max(weatherdata$lat),,n.grid)))
library(readr)                # Read csv files
library(INLA)                 # Compute discretization mesh and FEM matrices
library(leaflet)              # Interactive widgets
library(leaflet.extras)       # Fullscreen control for Leaflet widget
library(cmdstanr)             # CmdStan R interface
library(posterior)            # Process the output of cmdstanr sampling
library(bayesplot)            # Pair and trace plots
library(ggplot2)              # More plots
library(GIGrvg)               # Evaluate the density of a GIG distribution
source("../files/utils.R")    # Several utility functions
options(mc.cores = parallel::detectCores())
weatherdata <- as.data.frame(read_csv("../files/data/weatherdata.csv", col_names = TRUE))
mesh <- inla.mesh.2d(loc = weatherdata[,c("lon","lat")], max.edge = c(1.5, 2.5), cutoff = 0.3, max.n.strict = 400)
Ny   <- length(weatherdata$temp)                  #Number of observations
N    <- mesh$n                                    #Number of nodes
fem  <- inla.mesh.fem(mesh, order=2)
G    <- fem$g1
h    <- diag(fem$c0)
A <- inla.spde.make.A(mesh = mesh, loc = as.matrix(weatherdata[,c("lon","lat")]))
#Square grid containing 100^2 nodes
n.grid <- 100
coop <- as.data.frame(expand.grid(seq(min(weatherdata$lon),max(weatherdata$lon),,n.grid),
seq(min(weatherdata$lat),max(weatherdata$lat),,n.grid)))
lenx <- (max(weatherdata$lon) - min(weatherdata$lon))/n.grid
leny <- (max(weatherdata$lat) - min(weatherdata$lat))/n.grid
#projector matrix for new grid
Ap   <-  inla.spde.make.A(mesh = mesh, loc = as.matrix(coop))
#Posterior samples from w
W_NIG   <- as.matrix(as_draws_df(fit_NIG$draws("w"))[,1:N])
#Posterior samples from sigma
sigma_NIG   <- as.matrix(as_draws_df(fit_NIG$draws("sigmax")))[,1]
#Posterior samples of w_pred
W_NIG_pred   <- sigma_NIG * t(Ap %*% t(W_NIG))
W_pred <- W_NIG_pred
# Plot data
colnames(coop) <- c("lng1","lat1")
coop$lng2 <- coop$lng1 + 1.01*lenx
coop$lat2 <- coop$lat1 + 1.01*leny
plot_data <- data.frame(lng1 = coop$lng1, lng2 = coop$lng2, lat1 = coop$lat1, lat2 = coop$lat2,
mean = colMeans(W_pred),
sd  = apply(W_pred,2,sd),
p4  = apply(W_pred,2,function(x) mean(x> 600)),
pm4  = apply(W_pred,2,function(x) mean(x< -400)))
#pop-up labels
dataset   <- as.matrix(as_draws_df(fit_NIG$draws("my"))[,1:Ny])
data      <- round(weatherdata$press,2)
nigprep   <- round(colMeans(dataset),2)
q05       <- round(apply(dataset, 2, quantile, 0.05),2)
q95       <- round(apply(dataset, 2, quantile, 0.95),2)
labels <- sprintf(
"<strong> Observed: </strong> %s <br/> <strong>Prediction:</strong> %s  <br/> <strong>95p Quantiles: </strong> [%s, %s]",
round(weatherdata$press,2), round(colMeans(dataset),2),round(apply(dataset, 2, quantile, 0.05),2), round(apply(dataset, 2, quantile, 0.95),2)) %>%
lapply(htmltools::HTML)
#Cutoff for probability plots
plot_data$include.p4 <- as.numeric(plot_data$p4>0.1)
plot_data$include.pm4 <- as.numeric(plot_data$pm4>0.1)
#Palletes
pal.mean  <- colorNumeric(palette = c("blue","white","red"), domain = c(-550,620))
pal.sd    <- colorNumeric(palette = c("YlOrRd"), domain = c(10,230))
pal.p4    <- colorNumeric(palette = c("white","red"), domain = plot_data$p4)
pal.pm4   <- colorNumeric(palette = c("white","blue"), domain = plot_data$pm4)
leaflet(plot_data) %>%
addTiles(group = "OpenStreetMap") %>%
addProviderTiles(providers$Esri.WorldImagery, group = "Sattelite") %>%
addCircleMarkers(data = weatherdata, lng = ~lon, lat = ~lat, color="black",
stroke= TRUE, fill = TRUE, fillColor = ~palpress(press),
radius = 5, fillOpacity = TRUE, weight = 1, label = labels) %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.mean(mean), fillOpacity = 0.8, stroke = FALSE, group = "Mean") %>%
addLegend_decreasing(pal = pal.mean, values = ~mean, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Mean") %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.sd(sd), fillOpacity = 0.8, stroke = FALSE, group = "Standard Deviation") %>%
addLegend_decreasing(pal = pal.sd, values = ~sd, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Standard Deviation") %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.p4(p4), fillOpacity = ~include.p4*0.8, stroke = FALSE, group = "Prob > 600") %>%
addLegend_decreasing(pal = pal.p4, values = ~p4, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Prob > 600") %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.pm4(pm4), fillOpacity = ~include.pm4*0.8, stroke = FALSE, group = "Prob < -400") %>%
addLegend_decreasing(pal = pal.pm4, values = ~pm4, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Prob < -400") %>%
addLayersControl(baseGroups = c("OpenStreetMap", "Sattelite"),
overlayGroups = c("Mean", "Standard Deviation", "Prob > 600", "Prob < -400"),
options = layersControlOptions(collapsed = FALSE)) %>%
hideGroup(c("Standard Deviation", "Prob > 600", "Prob < -400")) %>%
addFullscreenControl()
#inla.mesh2sp is a function in ../files/utils.R that convert an INLA mesh object to an sp mesh object that leaflet can process
mesh_map <- inla.mesh2sp(mesh)$triangles
#Leaflet expects data to be specified in latitude and longitude using the WGS84 coordinate projection, so we transform mesh_map to this projection as follows
proj4string(mesh_map) <- CRS("+proj=longlat +datum=WGS84")
mesh_map_proj <- spTransform(mesh_map, "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
paltemp  <- colorNumeric(palette = c("blue","white","red"), domain = weatherdata$temp)   #pallete for temperature data
palpress <- colorNumeric(palette = c("blue","white","red"), domain = weatherdata$press)  #pallete for pressure    data
leaflet(weatherdata) %>%
addProviderTiles(providers$Stamen.Terrain) %>%
#Discretization mesh
addPolygons(data=mesh_map_proj, weight = 1, fill = FALSE, color = "#0A0708") %>%
#Temperature circle markers
addCircleMarkers(lng = ~lon, lat = ~lat, color="black",
stroke= TRUE, fill = TRUE, fillColor = ~paltemp(temp),
radius = 5, fillOpacity = TRUE, weight = 1, group = "Temperature") %>%
#Legend for temperature data
addLegend_decreasing(pal = paltemp, values = ~temp, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Temperature") %>%
#Pressure circle markers
addCircleMarkers(lng = ~lon, lat = ~lat, color="black",
stroke= TRUE, fill = TRUE, fillColor = ~palpress(press),
radius = 5, fillOpacity = TRUE, weight = 1, group = "Pressure") %>%
#Legend for pressure data
addLegend_decreasing(pal = palpress, values = ~press, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Pressure") %>%
#Layers
addLayersControl(overlayGroups = c("Temperature", "Pressure"),
options = layersControlOptions(collapsed = FALSE)) %>%
hideGroup("Pressure") %>%
addFullscreenControl()
W_pred <- W_NIG_pred
# Plot data
colnames(coop) <- c("lng1","lat1")
coop$lng2 <- coop$lng1 + 1.01*lenx
coop$lat2 <- coop$lat1 + 1.01*leny
plot_data <- data.frame(lng1 = coop$lng1, lng2 = coop$lng2, lat1 = coop$lat1, lat2 = coop$lat2,
mean = colMeans(W_pred),
sd  = apply(W_pred,2,sd),
p4  = apply(W_pred,2,function(x) mean(x> 600)),
pm4  = apply(W_pred,2,function(x) mean(x< -400)))
#pop-up labels
dataset   <- as.matrix(as_draws_df(fit_NIG$draws("my"))[,1:Ny])
data      <- round(weatherdata$press,2)
nigprep   <- round(colMeans(dataset),2)
q05       <- round(apply(dataset, 2, quantile, 0.05),2)
q95       <- round(apply(dataset, 2, quantile, 0.95),2)
labels <- sprintf(
"<strong> Observed: </strong> %s <br/> <strong>Prediction:</strong> %s  <br/> <strong>95p Quantiles: </strong> [%s, %s]",
round(weatherdata$press,2), round(colMeans(dataset),2),round(apply(dataset, 2, quantile, 0.05),2), round(apply(dataset, 2, quantile, 0.95),2)) %>%
lapply(htmltools::HTML)
#Cutoff for probability plots
plot_data$include.p4 <- as.numeric(plot_data$p4>0.1)
plot_data$include.pm4 <- as.numeric(plot_data$pm4>0.1)
#Palletes
pal.mean  <- colorNumeric(palette = c("blue","white","red"), domain = c(-550,620))
pal.sd    <- colorNumeric(palette = c("YlOrRd"), domain = c(10,230))
pal.p4    <- colorNumeric(palette = c("white","red"), domain = plot_data$p4)
pal.pm4   <- colorNumeric(palette = c("white","blue"), domain = plot_data$pm4)
leaflet(plot_data) %>%
addTiles(group = "OpenStreetMap") %>%
addProviderTiles(providers$Esri.WorldImagery, group = "Sattelite") %>%
addCircleMarkers(data = weatherdata, lng = ~lon, lat = ~lat, color="black",
stroke= TRUE, fill = TRUE, fillColor = ~palpress(press),
radius = 5, fillOpacity = TRUE, weight = 1, label = labels) %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.mean(mean), fillOpacity = 0.8, stroke = FALSE, group = "Mean") %>%
addLegend_decreasing(pal = pal.mean, values = ~mean, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Mean") %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.sd(sd), fillOpacity = 0.8, stroke = FALSE, group = "Standard Deviation") %>%
addLegend_decreasing(pal = pal.sd, values = ~sd, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Standard Deviation") %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.p4(p4), fillOpacity = ~include.p4*0.8, stroke = FALSE, group = "Prob > 600") %>%
addLegend_decreasing(pal = pal.p4, values = ~p4, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Prob > 600") %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.pm4(pm4), fillOpacity = ~include.pm4*0.8, stroke = FALSE, group = "Prob < -400") %>%
addLegend_decreasing(pal = pal.pm4, values = ~pm4, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Prob < -400") %>%
addLayersControl(baseGroups = c("OpenStreetMap", "Sattelite"),
overlayGroups = c("Mean", "Standard Deviation", "Prob > 600", "Prob < -400"),
options = layersControlOptions(collapsed = FALSE)) %>%
hideGroup(c("Standard Deviation", "Prob > 600", "Prob < -400")) %>%
addFullscreenControl()
#Posterior samples from w
W_Gauss      <- as.matrix(as_draws_df(fit_Gauss$draws("w"))[,1:N])
#Posterior samples from sigma
sigma_Gauss  <- as.matrix(as_draws_df(fit_Gauss$draws("sigmax")))[,1]
#Posterior samples of w_pred
W_Gauss_pred <- sigma_Gauss * t(Ap %*% t(W_Gauss))
W_pred <- W_Gauss_pred
# Plot data
colnames(coop) <- c("lng1","lat1")
coop$lng2 <- coop$lng1 + 1.01*lenx
coop$lat2 <- coop$lat1 + 1.01*leny
plot_data <- data.frame(lng1 = coop$lng1, lng2 = coop$lng2, lat1 = coop$lat1, lat2 = coop$lat2,
mean = colMeans(W_pred),
sd  = apply(W_pred,2,sd),
p4  = apply(W_pred,2,function(x) mean(x> 600)),
pm4  = apply(W_pred,2,function(x) mean(x< -400)))
#pop-up labels
dataset   <- as.matrix(as_draws_df(fit_Gauss$draws("my"))[,1:Ny])
data      <- round(weatherdata$press,2)
nigprep   <- round(colMeans(dataset),2)
q05       <- round(apply(dataset, 2, quantile, 0.05),2)
q95       <- round(apply(dataset, 2, quantile, 0.95),2)
labels <- sprintf(
"<strong> Observed: </strong> %s <br/> <strong>Prediction:</strong> %s  <br/> <strong>95p Quantiles: </strong> [%s, %s]",
round(weatherdata$press,2), round(colMeans(dataset),2),round(apply(dataset, 2, quantile, 0.05),2), round(apply(dataset, 2, quantile, 0.95),2)) %>%
lapply(htmltools::HTML)
#Cutoff for probability plots
plot_data$include.p4 <- as.numeric(plot_data$p4>0.1)
plot_data$include.pm4 <- as.numeric(plot_data$pm4>0.1)
#Palletes
pal.mean  <- colorNumeric(palette = c("blue","white","red"), domain = c(-550,620))
pal.sd    <- colorNumeric(palette = c("YlOrRd"), domain = c(10,230))
pal.p4    <- colorNumeric(palette = c("white","red"), domain = plot_data$p4)
pal.pm4   <- colorNumeric(palette = c("white","blue"), domain = plot_data$pm4)
leaflet(plot_data) %>%
addTiles(group = "OpenStreetMap") %>%
addProviderTiles(providers$Esri.WorldImagery, group = "Sattelite") %>%
addCircleMarkers(data = weatherdata, lng = ~lon, lat = ~lat, color="black",
stroke= TRUE, fill = TRUE, fillColor = ~palpress(press),
radius = 5, fillOpacity = TRUE, weight = 1, label = labels) %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.mean(mean), fillOpacity = 0.8, stroke = FALSE, group = "Mean") %>%
addLegend_decreasing(pal = pal.mean, values = ~mean, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Mean") %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.sd(sd), fillOpacity = 0.8, stroke = FALSE, group = "Standard Deviation") %>%
addLegend_decreasing(pal = pal.sd, values = ~sd, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Standard Deviation") %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.p4(p4), fillOpacity = ~include.p4*0.8, stroke = FALSE, group = "Prob > 600") %>%
addLegend_decreasing(pal = pal.p4, values = ~p4, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Prob > 600") %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.pm4(pm4), fillOpacity = ~include.pm4*0.8, stroke = FALSE, group = "Prob < -200") %>%
addLegend_decreasing(pal = pal.pm4, values = ~pm4, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Prob < -200") %>%
addLayersControl(baseGroups = c("OpenStreetMap", "Sattelite"),
overlayGroups = c("Mean", "Standard Deviation", "Prob > 600", "Prob < -200"),
options = layersControlOptions(collapsed = FALSE)) %>%
hideGroup(c("Standard Deviation", "Prob > 400", "Prob < -200"))%>%
addFullscreenControl()
#Posterior samples from w
W_Gauss      <- as.matrix(as_draws_df(fit_Gauss$draws("w"))[,1:N])
#Posterior samples from sigma
sigma_Gauss  <- as.matrix(as_draws_df(fit_Gauss$draws("sigmax")))[,1]
#Posterior samples of w_pred
W_Gauss_pred <- sigma_Gauss * t(Ap %*% t(W_Gauss))
W_pred <- W_Gauss_pred
# Plot data
colnames(coop) <- c("lng1","lat1")
coop$lng2 <- coop$lng1 + 1.01*lenx
coop$lat2 <- coop$lat1 + 1.01*leny
plot_data <- data.frame(lng1 = coop$lng1, lng2 = coop$lng2, lat1 = coop$lat1, lat2 = coop$lat2,
mean = colMeans(W_pred),
sd  = apply(W_pred,2,sd),
p4  = apply(W_pred,2,function(x) mean(x> 600)),
pm4  = apply(W_pred,2,function(x) mean(x< -400)))
#pop-up labels
dataset   <- as.matrix(as_draws_df(fit_Gauss$draws("my"))[,1:Ny])
data      <- round(weatherdata$press,2)
nigprep   <- round(colMeans(dataset),2)
q05       <- round(apply(dataset, 2, quantile, 0.05),2)
q95       <- round(apply(dataset, 2, quantile, 0.95),2)
labels <- sprintf(
"<strong> Observed: </strong> %s <br/> <strong>Prediction:</strong> %s  <br/> <strong>95p Quantiles: </strong> [%s, %s]",
round(weatherdata$press,2), round(colMeans(dataset),2),round(apply(dataset, 2, quantile, 0.05),2), round(apply(dataset, 2, quantile, 0.95),2)) %>%
lapply(htmltools::HTML)
#Cutoff for probability plots
plot_data$include.p4 <- as.numeric(plot_data$p4>0.1)
plot_data$include.pm4 <- as.numeric(plot_data$pm4>0.1)
#Palletes
pal.mean  <- colorNumeric(palette = c("blue","white","red"), domain = c(-550,620))
pal.sd    <- colorNumeric(palette = c("YlOrRd"), domain = c(10,230))
pal.p4    <- colorNumeric(palette = c("white","red"), domain = plot_data$p4)
pal.pm4   <- colorNumeric(palette = c("white","blue"), domain = plot_data$pm4)
leaflet(plot_data) %>%
addTiles(group = "OpenStreetMap") %>%
addProviderTiles(providers$Esri.WorldImagery, group = "Sattelite") %>%
addCircleMarkers(data = weatherdata, lng = ~lon, lat = ~lat, color="black",
stroke= TRUE, fill = TRUE, fillColor = ~palpress(press),
radius = 5, fillOpacity = TRUE, weight = 1, label = labels) %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.mean(mean), fillOpacity = 0.8, stroke = FALSE, group = "Mean") %>%
addLegend_decreasing(pal = pal.mean, values = ~mean, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Mean") %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.sd(sd), fillOpacity = 0.8, stroke = FALSE, group = "Standard Deviation") %>%
addLegend_decreasing(pal = pal.sd, values = ~sd, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Standard Deviation") %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.p4(p4), fillOpacity = ~include.p4*0.8, stroke = FALSE, group = "Prob > 600") %>%
addLegend_decreasing(pal = pal.p4, values = ~p4, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Prob > 600") %>%
addRectangles(lng1 = ~lng1, lng2 = ~lng2, lat1 = ~lat1, lat2 = ~lat2,
fillColor = ~pal.pm4(pm4), fillOpacity = ~include.pm4*0.8, stroke = FALSE, group = "Prob < -400") %>%
addLegend_decreasing(pal = pal.pm4, values = ~pm4, opacity = 0.8, title = "",
position = "bottomright", decreasing = TRUE, group = "Prob < -400") %>%
addLayersControl(baseGroups = c("OpenStreetMap", "Sattelite"),
overlayGroups = c("Mean", "Standard Deviation", "Prob > 600", "Prob < -400"),
options = layersControlOptions(collapsed = FALSE)) %>%
hideGroup(c("Standard Deviation", "Prob > 600", "Prob < -400")) %>%
addFullscreenControl()
plot_data <- as.data.frame(mesh$loc[,c(1,2)])
plot_data$Vmean = log(Vmean)
kappa       <- as.matrix(as_draws_df(fit_NIG$draws("kappa")))[,1]
etas        <- as.matrix(as_draws_df(fit_NIG$draws("etas")))[,1]
zetas         <- as.matrix(as_draws_df(fit_NIG$draws("zetas")))[,1]
V      <- Vposterior(W_NIG, kappa, G, etas, zetas, h)
Vmean  <- colMeans(V)                                                           #posterior means of V/h
sel    <- 1-((apply(V,2,quantile,0.05) < 1) & (apply(V,2,quantile,0.95) > 1))*1 #do 95% quantiles include the value 1?
plot_data <- as.data.frame(mesh$loc[,c(1,2)])
plot_data$Vmean = log(Vmean)
colnames(plot_data) <- c("lon","lat","Vmean")
mesh_map <- inla.mesh2sp(mesh)$triangles
proj4string(mesh_map) <- CRS("+proj=longlat +datum=WGS84")
mesh_map_proj <- spTransform(mesh_map, "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
#Palletes
pal.Vmean  <- colorNumeric(palette = c("blue","white","red"), domain = plot_data$Vmean)
m <- leaflet(plot_data, options = leafletOptions(zoomControl = FALSE,  attributionControl=FALSE)) %>%
addTiles(group = "OpenStreetMap") %>%
addPolygons(data=mesh_map_proj, weight = 0.5, fill = FALSE, color = "#0A0708") %>%
addCircleMarkers(data = plot_data, lng = ~lon, lat = ~lat, color="black",
stroke= TRUE, fill = TRUE, fillColor = ~pal.Vmean(Vmean),
radius = 5, fillOpacity = TRUE, weight = sel*3 + 0.5, opacity = 1) %>%
addLegend_decreasing(pal = pal.Vmean, values = plot_data$Vmean, opacity = 0.8, title = "log(E[V]/h)",
position = "bottomright", decreasing = TRUE) %>%
addFullscreenControl()
plot_data <- as.data.frame(mesh$loc[,c(1,2)])
plot_data$Vmean = log(Vmean)
colnames(plot_data) <- c("lon","lat","Vmean")
mesh_map <- inla.mesh2sp(mesh)$triangles
proj4string(mesh_map) <- CRS("+proj=longlat +datum=WGS84")
mesh_map_proj <- spTransform(mesh_map, "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
#Palletes
pal.Vmean  <- colorNumeric(palette = c("blue","white","red"), domain = plot_data$Vmean)
m <- leaflet(plot_data, options = leafletOptions(zoomControl = FALSE,  attributionControl=FALSE)) %>%
addTiles(group = "OpenStreetMap") %>%
addPolygons(data=mesh_map_proj, weight = 0.5, fill = FALSE, color = "#0A0708") %>%
addCircleMarkers(data = plot_data, lng = ~lon, lat = ~lat, color="black",
stroke= TRUE, fill = TRUE, fillColor = ~pal.Vmean(Vmean),
radius = 5, fillOpacity = TRUE, weight = sel*3 + 0.5, opacity = 1) %>%
addLegend_decreasing(pal = pal.Vmean, values = plot_data$Vmean, opacity = 0.8, title = "log(E[V]/h)",
position = "bottomright", decreasing = TRUE) %>%
addFullscreenControl()
plot_data <- as.data.frame(mesh$loc[,c(1,2)])
plot_data$Vmean = log(Vmean)
colnames(plot_data) <- c("lon","lat","Vmean")
mesh_map <- inla.mesh2sp(mesh)$triangles
proj4string(mesh_map) <- CRS("+proj=longlat +datum=WGS84")
mesh_map_proj <- spTransform(mesh_map, "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
#Palletes
pal.Vmean  <- colorNumeric(palette = c("blue","white","red"), domain = plot_data$Vmean)
leaflet(plot_data, options = leafletOptions(zoomControl = FALSE,  attributionControl=FALSE)) %>%
addTiles(group = "OpenStreetMap") %>%
addPolygons(data=mesh_map_proj, weight = 0.5, fill = FALSE, color = "#0A0708") %>%
addCircleMarkers(data = plot_data, lng = ~lon, lat = ~lat, color="black",
stroke= TRUE, fill = TRUE, fillColor = ~pal.Vmean(Vmean),
radius = 5, fillOpacity = TRUE, weight = sel*3 + 0.5, opacity = 1) %>%
addLegend_decreasing(pal = pal.Vmean, values = plot_data$Vmean, opacity = 0.8, title = "log(E[V]/h)",
position = "bottomright", decreasing = TRUE) %>%
addFullscreenControl()
plot_data <- as.data.frame(mesh$loc[,c(1,2)])
plot_data$Vmean = log(Vmean)
colnames(plot_data) <- c("lon","lat","Vmean")
mesh_map <- inla.mesh2sp(mesh)$triangles
proj4string(mesh_map) <- CRS("+proj=longlat +datum=WGS84")
mesh_map_proj <- spTransform(mesh_map, "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
#Palletes
pal.Vmean  <- colorNumeric(palette = c("blue","white","red"), domain = plot_data$Vmean)
m <- leaflet(plot_data, options = leafletOptions(zoomControl = FALSE,  attributionControl=FALSE)) %>%
addTiles(group = "OpenStreetMap") %>%
addPolygons(data=mesh_map_proj, weight = 0.5, fill = FALSE, color = "#0A0708") %>%
addCircleMarkers(data = plot_data, lng = ~lon, lat = ~lat, color="black",
stroke= TRUE, fill = TRUE, fillColor = ~pal.Vmean(Vmean),
radius = 5, fillOpacity = TRUE, weight = sel*3 + 0.5, opacity = 1) %>%
addLegend_decreasing(pal = pal.Vmean, values = plot_data$Vmean, opacity = 0.8, title = "log(E[V]/h)",
position = "bottomright", decreasing = TRUE)
setView(m, -121.9, 47.39, 5.4)
plot_data <- as.data.frame(mesh$loc[,c(1,2)])
plot_data$Vmean = log(Vmean)
colnames(plot_data) <- c("lon","lat","Vmean")
mesh_map <- inla.mesh2sp(mesh)$triangles
proj4string(mesh_map) <- CRS("+proj=longlat +datum=WGS84")
mesh_map_proj <- spTransform(mesh_map, "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
#Palletes
pal.Vmean  <- colorNumeric(palette = c("blue","white","red"), domain = plot_data$Vmean)
m <- leaflet(plot_data, options = leafletOptions(zoomControl = FALSE,  attributionControl=FALSE)) %>%
addTiles(group = "OpenStreetMap") %>%
addPolygons(data=mesh_map_proj, weight = 0.5, fill = FALSE, color = "#0A0708") %>%
addCircleMarkers(data = plot_data, lng = ~lon, lat = ~lat, color="black",
stroke= TRUE, fill = TRUE, fillColor = ~pal.Vmean(Vmean),
radius = 5, fillOpacity = TRUE, weight = sel*3 + 0.5, opacity = 1) %>%
addLegend_decreasing(pal = pal.Vmean, values = plot_data$Vmean, opacity = 0.8, title = "log(E[V]/h)",
position = "bottomright", decreasing = TRUE)
setView(m, -121.9, 47.39, 5.4)
